#include "renderer/ocl/kernels/kernels.h"
string KernelSource_kernel_core = 
"/***************************************************************************\n"
" *   Copyright (C) 1998-2010 by authors (see AUTHORS.txt)                  *\n"
" *                                                                         *\n"
" *   This file is part of Sfera.                                           *\n"
" *                                                                         *\n"
" *   Sfera is free software; you can redistribute it and/or modify         *\n"
" *   it under the terms of the GNU General Public License as published by  *\n"
" *   the Free Software Foundation; either version 3 of the License, or     *\n"
" *   (at your option) any later version.                                   *\n"
" *                                                                         *\n"
" *   Sfera is distributed in the hope that it will be useful,              *\n"
" *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n"
" *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n"
" *   GNU General Public License for more details.                          *\n"
" *                                                                         *\n"
" *   You should have received a copy of the GNU General Public License     *\n"
" *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *\n"
" *                                                                         *\n"
" ***************************************************************************/\n"
"// List of symbols defined at compile time:\n"
"//  PARAM_SCREEN_WIDTH\n"
"//  PARAM_SCREEN_HEIGHT\n"
"\n"
"#ifndef M_PI\n"
"#define M_PI 3.14159265358979323846f\n"
"#endif\n"
"\n"
"#ifndef INV_PI\n"
"#define INV_PI  0.31830988618379067154f\n"
"#endif\n"
"\n"
"#ifndef INV_TWOPI\n"
"#define INV_TWOPI  0.15915494309189533577f\n"
"#endif\n"
"\n"
"#ifndef TRUE\n"
"#define TRUE 1\n"
"#endif\n"
"\n"
"#ifndef FALSE\n"
"#define FALSE 0\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Types\n"
"//------------------------------------------------------------------------------\n"
"\n"
"typedef struct {\n"
"	float u, v;\n"
"} UV;\n"
"\n"
"typedef struct {\n"
"	float r, g, b;\n"
"} Spectrum;\n"
"\n"
"typedef struct {\n"
"	float x, y, z;\n"
"} Point;\n"
"\n"
"typedef struct {\n"
"	float x, y, z;\n"
"} Vector;\n"
"\n"
"typedef struct {\n"
"	Point o;\n"
"	Vector d;\n"
"	float mint, maxt;\n"
"} Ray;\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"typedef struct {\n"
"	unsigned int s1, s2, s3;\n"
"} Seed;\n"
"\n"
"typedef struct {\n"
"	// The task seed\n"
"	Seed seed;\n"
"} GPUTask;\n"
"\n"
"typedef Spectrum Pixel;\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#define MAT_MATTE 0\n"
"#define MAT_MIRROR 1\n"
"#define MAT_GLASS 2\n"
"#define MAT_METAL 3\n"
"#define MAT_ALLOY 4\n"
"\n"
"typedef struct {\n"
"    float r, g, b;\n"
"} MatteParam;\n"
"\n"
"typedef struct {\n"
"    float r, g, b;\n"
"    int specularBounce;\n"
"} MirrorParam;\n"
"\n"
"typedef struct {\n"
"    float refl_r, refl_g, refl_b;\n"
"    float refrct_r, refrct_g, refrct_b;\n"
"    float ousideIor, ior;\n"
"    float R0;\n"
"    int reflectionSpecularBounce, transmitionSpecularBounce;\n"
"} GlassParam;\n"
"\n"
"typedef struct {\n"
"    float r, g, b;\n"
"    float exponent;\n"
"    int specularBounce;\n"
"} MetalParam;\n"
"\n"
"typedef struct {\n"
"    float diff_r, diff_g, diff_b;\n"
"    float refl_r, refl_g, refl_b;\n"
"    float exponent;\n"
"    float R0;\n"
"    int specularBounce;\n"
"} AlloyParam;\n"
"\n"
"typedef struct {\n"
"	unsigned int type;\n"
"	union {\n"
"		MatteParam matte;\n"
"		MirrorParam mirror;\n"
"        GlassParam glass;\n"
"        MetalParam metal;\n"
"        AlloyParam alloy;\n"
"	} param;\n"
"} Material;\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"typedef struct {\n"
"	Point v0, v1, v2;\n"
"	Vector normal;\n"
"	float area;\n"
"	float gain_r, gain_g, gain_b;\n"
"} TriangleLight;\n"
"\n"
"typedef struct {\n"
"	float shiftU, shiftV;\n"
"	Spectrum gain;\n"
"	uint width, height;\n"
"} InfiniteLight;\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"typedef struct {\n"
"	uint rgbOffset, alphaOffset;\n"
"	uint width, height;\n"
"} TexMap;\n"
"\n"
"typedef struct {\n"
"	float lensRadius;\n"
"	float focalDistance;\n"
"	float yon, hither;\n"
"\n"
"	float rasterToCameraMatrix[4][4];\n"
"	float cameraToWorldMatrix[4][4];\n"
"} Camera;\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// Random number generator\n"
"// maximally equidistributed combined Tausworthe generator\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#define FLOATMASK 0x00ffffffu\n"
"\n"
"uint TAUSWORTHE(const uint s, const uint a,\n"
"	const uint b, const uint c,\n"
"	const uint d) {\n"
"	return ((s&c)<<d) ^ (((s << a) ^ s) >> b);\n"
"}\n"
"\n"
"uint LCG(const uint x) { return x * 69069; }\n"
"\n"
"uint ValidSeed(const uint x, const uint m) {\n"
"	return (x < m) ? (x + m) : x;\n"
"}\n"
"\n"
"void InitRandomGenerator(uint seed, Seed *s) {\n"
"	// Avoid 0 value\n"
"	seed = (seed == 0) ? (seed + 0xffffffu) : seed;\n"
"\n"
"	s->s1 = ValidSeed(LCG(seed), 1);\n"
"	s->s2 = ValidSeed(LCG(s->s1), 7);\n"
"	s->s3 = ValidSeed(LCG(s->s2), 15);\n"
"}\n"
"\n"
"unsigned long RndUintValue(Seed *s) {\n"
"	s->s1 = TAUSWORTHE(s->s1, 13, 19, 4294967294UL, 12);\n"
"	s->s2 = TAUSWORTHE(s->s2, 2, 25, 4294967288UL, 4);\n"
"	s->s3 = TAUSWORTHE(s->s3, 3, 11, 4294967280UL, 17);\n"
"\n"
"	return ((s->s1) ^ (s->s2) ^ (s->s3));\n"
"}\n"
"\n"
"float RndFloatValue(Seed *s) {\n"
"	return (RndUintValue(s) & FLOATMASK) * (1.f / (FLOATMASK + 1UL));\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"float Spectrum_Y(const Spectrum *s) {\n"
"	return 0.212671f * s->r + 0.715160f * s->g + 0.072169f * s->b;\n"
"}\n"
"\n"
"float Dot(const Vector *v0, const Vector *v1) {\n"
"	return v0->x * v1->x + v0->y * v1->y + v0->z * v1->z;\n"
"}\n"
"\n"
"void Normalize(Vector *v) {\n"
"	const float il = 1.f / sqrt(Dot(v, v));\n"
"\n"
"	v->x *= il;\n"
"	v->y *= il;\n"
"	v->z *= il;\n"
"}\n"
"\n"
"void Cross(Vector *v3, const Vector *v1, const Vector *v2) {\n"
"	v3->x = (v1->y * v2->z) - (v1->z * v2->y);\n"
"	v3->y = (v1->z * v2->x) - (v1->x * v2->z),\n"
"	v3->z = (v1->x * v2->y) - (v1->y * v2->x);\n"
"}\n"
"\n"
"int Mod(int a, int b) {\n"
"	if (b == 0)\n"
"		b = 1;\n"
"\n"
"	a %= b;\n"
"	if (a < 0)\n"
"		a += b;\n"
"\n"
"	return a;\n"
"}\n"
"\n"
"float Lerp(float t, float v1, float v2) {\n"
"	return (1.f - t) * v1 + t * v2;\n"
"}\n"
"\n"
"void ConcentricSampleDisk(const float u1, const float u2, float *dx, float *dy) {\n"
"	float r, theta;\n"
"	// Map uniform random numbers to $[-1,1]^2$\n"
"	float sx = 2.f * u1 - 1.f;\n"
"	float sy = 2.f * u2 - 1.f;\n"
"	// Map square to $(r,\theta)$\n"
"	// Handle degeneracy at the origin\n"
"	if (sx == 0.f && sy == 0.f) {\n"
"		*dx = 0.f;\n"
"		*dy = 0.f;\n"
"		return;\n"
"	}\n"
"	if (sx >= -sy) {\n"
"		if (sx > sy) {\n"
"			// Handle first region of disk\n"
"			r = sx;\n"
"			if (sy > 0.f)\n"
"				theta = sy / r;\n"
"			else\n"
"				theta = 8.f + sy / r;\n"
"		} else {\n"
"			// Handle second region of disk\n"
"			r = sy;\n"
"			theta = 2.f - sx / r;\n"
"		}\n"
"	} else {\n"
"		if (sx <= sy) {\n"
"			// Handle third region of disk\n"
"			r = -sx;\n"
"			theta = 4.f - sy / r;\n"
"		} else {\n"
"			// Handle fourth region of disk\n"
"			r = -sy;\n"
"			theta = 6.f + sx / r;\n"
"		}\n"
"	}\n"
"	theta *= M_PI / 4.f;\n"
"	*dx = r * cos(theta);\n"
"	*dy = r * sin(theta);\n"
"}\n"
"\n"
"void CosineSampleHemisphere(Vector *ret, const float u1, const float u2) {\n"
"	ConcentricSampleDisk(u1, u2, &ret->x, &ret->y);\n"
"	ret->z = sqrt(max(0.f, 1.f - ret->x * ret->x - ret->y * ret->y));\n"
"}\n"
"\n"
"void UniformSampleCone(Vector *ret, const float u1, const float u2, const float costhetamax,\n"
"	const Vector *x, const Vector *y, const Vector *z) {\n"
"	const float costheta = Lerp(u1, costhetamax, 1.f);\n"
"	const float sintheta = sqrt(1.f - costheta * costheta);\n"
"	const float phi = u2 * 2.f * M_PI;\n"
"\n"
"	const float kx = cos(phi) * sintheta;\n"
"	const float ky = sin(phi) * sintheta;\n"
"	const float kz = costheta;\n"
"\n"
"	ret->x = kx * x->x + ky * y->x + kz * z->x;\n"
"	ret->y = kx * x->y + ky * y->y + kz * z->y;\n"
"	ret->z = kx * x->z + ky * y->z + kz * z->z;\n"
"}\n"
"\n"
"float UniformConePdf(float costhetamax) {\n"
"	return 1.f / (2.f * M_PI * (1.f - costhetamax));\n"
"}\n"
"\n"
"void CoordinateSystem(const Vector *v1, Vector *v2, Vector *v3) {\n"
"	if (fabs(v1->x) > fabs(v1->y)) {\n"
"		float invLen = 1.f / sqrt(v1->x * v1->x + v1->z * v1->z);\n"
"		v2->x = -v1->z * invLen;\n"
"		v2->y = 0.f;\n"
"		v2->z = v1->x * invLen;\n"
"	} else {\n"
"		float invLen = 1.f / sqrt(v1->y * v1->y + v1->z * v1->z);\n"
"		v2->x = 0.f;\n"
"		v2->y = v1->z * invLen;\n"
"		v2->z = -v1->y * invLen;\n"
"	}\n"
"\n"
"	Cross(v3, v1, v2);\n"
"}\n"
"\n"
"float SphericalTheta(const Vector *v) {\n"
"	return acos(clamp(v->z, -1.f, 1.f));\n"
"}\n"
"\n"
"float SphericalPhi(const Vector *v) {\n"
"	float p = atan2(v->y, v->x);\n"
"	return (p < 0.f) ? p + 2.f * M_PI : p;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// InitFB Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"__kernel void InitFB(\n"
"		__global Pixel *frameBuffer\n"
"		) {\n"
"	const size_t gid = get_global_id(0);\n"
"	if (gid >= PARAM_SCREEN_WIDTH * PARAM_SCREEN_HEIGHT)\n"
"		return;\n"
"\n"
"	__global Pixel *p = &frameBuffer[gid];\n"
"	p->r = (gid / PARAM_SCREEN_WIDTH) / (float)PARAM_SCREEN_HEIGHT;\n"
"	p->g = 0.f;\n"
"	p->b = 0.f;\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"// UpdatePixelBuffer Kernel\n"
"//------------------------------------------------------------------------------\n"
"\n"
"uint Radiance2PixelUInt(const float x) {\n"
"	return (uint)(pow(clamp(x, 0.f, 1.f), 1.f / 2.2f) * 255.f + .5f);\n"
"}\n"
"\n"
"__kernel void UpdatePixelBuffer(\n"
"		__global Pixel *frameBuffer,\n"
"		__global uint *pbo) {\n"
"	const int gid = get_global_id(0);\n"
"	if (gid >= PARAM_SCREEN_WIDTH * PARAM_SCREEN_HEIGHT)\n"
"		return;\n"
"\n"
"	__global Pixel *p = &frameBuffer[gid];\n"
"\n"
"	const uint r = Radiance2PixelUInt(p->r);\n"
"	const uint g = Radiance2PixelUInt(p->g);\n"
"	const uint b = Radiance2PixelUInt(p->b);\n"
"	pbo[gid] = r | (g << 8) | (b << 16);\n"
"}\n"
;
